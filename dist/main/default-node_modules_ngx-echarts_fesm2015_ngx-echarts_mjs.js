"use strict";
(self["webpackChunkcliniva"] = self["webpackChunkcliniva"] || []).push([["default-node_modules_ngx-echarts_fesm2015_ngx-echarts_mjs"],{

/***/ 9156:
/*!*******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm/internal/operators/throttle.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultThrottleConfig": () => (/* binding */ defaultThrottleConfig),
/* harmony export */   "throttle": () => (/* binding */ throttle)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ 41944);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ 93945);
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../observable/innerFrom */ 54987);



const defaultThrottleConfig = {
    leading: true,
    trailing: false,
};
function throttle(durationSelector, config = defaultThrottleConfig) {
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)((source, subscriber) => {
        const { leading, trailing } = config;
        let hasValue = false;
        let sendValue = null;
        let throttled = null;
        let isComplete = false;
        const endThrottling = () => {
            throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
            throttled = null;
            if (trailing) {
                send();
                isComplete && subscriber.complete();
            }
        };
        const cleanupThrottling = () => {
            throttled = null;
            isComplete && subscriber.complete();
        };
        const startThrottle = (value) => (throttled = (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_1__.innerFrom)(durationSelector(value)).subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, endThrottling, cleanupThrottling)));
        const send = () => {
            if (hasValue) {
                hasValue = false;
                const value = sendValue;
                sendValue = null;
                subscriber.next(value);
                !isComplete && startThrottle(value);
            }
        };
        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, (value) => {
            hasValue = true;
            sendValue = value;
            !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
        }, () => {
            isComplete = true;
            !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
        }));
    });
}


/***/ }),

/***/ 35004:
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm/internal/operators/throttleTime.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "throttleTime": () => (/* binding */ throttleTime)
/* harmony export */ });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scheduler/async */ 96936);
/* harmony import */ var _throttle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./throttle */ 9156);
/* harmony import */ var _observable_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observable/timer */ 78947);



function throttleTime(duration, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.asyncScheduler, config = _throttle__WEBPACK_IMPORTED_MODULE_1__.defaultThrottleConfig) {
  const duration$ = (0,_observable_timer__WEBPACK_IMPORTED_MODULE_2__.timer)(duration, scheduler);
  return (0,_throttle__WEBPACK_IMPORTED_MODULE_1__.throttle)(() => duration$, config);
}

/***/ }),

/***/ 45877:
/*!***********************************************************!*\
  !*** ./node_modules/ngx-echarts/fesm2015/ngx-echarts.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NGX_ECHARTS_CONFIG": () => (/* binding */ NGX_ECHARTS_CONFIG),
/* harmony export */   "NgxEchartsDirective": () => (/* binding */ NgxEchartsDirective),
/* harmony export */   "NgxEchartsModule": () => (/* binding */ NgxEchartsModule)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ 3184);
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tslib */ 34929);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ 10745);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ 20591);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ 80228);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ 96936);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs */ 90833);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ 35004);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ 32673);






class ChangeFilter {
  constructor(changes) {
    this.changes = changes;
  }

  static of(changes) {
    return new ChangeFilter(changes);
  }

  notEmpty(key) {
    if (this.changes[key]) {
      const value = this.changes[key].currentValue;

      if (value !== undefined && value !== null) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.of)(value);
      }
    }

    return rxjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY;
  }

  has(key) {
    if (this.changes[key]) {
      const value = this.changes[key].currentValue;
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.of)(value);
    }

    return rxjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY;
  }

  notFirst(key) {
    if (this.changes[key] && !this.changes[key].isFirstChange()) {
      const value = this.changes[key].currentValue;
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.of)(value);
    }

    return rxjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY;
  }

  notFirstAndEmpty(key) {
    if (this.changes[key] && !this.changes[key].isFirstChange()) {
      const value = this.changes[key].currentValue;

      if (value !== undefined && value !== null) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.of)(value);
      }
    }

    return rxjs__WEBPACK_IMPORTED_MODULE_1__.EMPTY;
  }

}

const NGX_ECHARTS_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken('NGX_ECHARTS_CONFIG');

class NgxEchartsDirective {
  constructor(config, el, ngZone) {
    this.el = el;
    this.ngZone = ngZone;
    this.autoResize = true;
    this.loadingType = 'default'; // ngx-echarts events

    this.chartInit = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.EventEmitter();
    this.optionsError = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.EventEmitter(); // echarts mouse events

    this.chartClick = this.createLazyEvent('click');
    this.chartDblClick = this.createLazyEvent('dblclick');
    this.chartMouseDown = this.createLazyEvent('mousedown');
    this.chartMouseMove = this.createLazyEvent('mousemove');
    this.chartMouseUp = this.createLazyEvent('mouseup');
    this.chartMouseOver = this.createLazyEvent('mouseover');
    this.chartMouseOut = this.createLazyEvent('mouseout');
    this.chartGlobalOut = this.createLazyEvent('globalout');
    this.chartContextMenu = this.createLazyEvent('contextmenu'); // echarts mouse events

    this.chartLegendSelectChanged = this.createLazyEvent('legendselectchanged');
    this.chartLegendSelected = this.createLazyEvent('legendselected');
    this.chartLegendUnselected = this.createLazyEvent('legendunselected');
    this.chartLegendScroll = this.createLazyEvent('legendscroll');
    this.chartDataZoom = this.createLazyEvent('datazoom');
    this.chartDataRangeSelected = this.createLazyEvent('datarangeselected');
    this.chartTimelineChanged = this.createLazyEvent('timelinechanged');
    this.chartTimelinePlayChanged = this.createLazyEvent('timelineplaychanged');
    this.chartRestore = this.createLazyEvent('restore');
    this.chartDataViewChanged = this.createLazyEvent('dataviewchanged');
    this.chartMagicTypeChanged = this.createLazyEvent('magictypechanged');
    this.chartPieSelectChanged = this.createLazyEvent('pieselectchanged');
    this.chartPieSelected = this.createLazyEvent('pieselected');
    this.chartPieUnselected = this.createLazyEvent('pieunselected');
    this.chartMapSelectChanged = this.createLazyEvent('mapselectchanged');
    this.chartMapSelected = this.createLazyEvent('mapselected');
    this.chartMapUnselected = this.createLazyEvent('mapunselected');
    this.chartAxisAreaSelected = this.createLazyEvent('axisareaselected');
    this.chartFocusNodeAdjacency = this.createLazyEvent('focusnodeadjacency');
    this.chartUnfocusNodeAdjacency = this.createLazyEvent('unfocusnodeadjacency');
    this.chartBrush = this.createLazyEvent('brush');
    this.chartBrushEnd = this.createLazyEvent('brushend');
    this.chartBrushSelected = this.createLazyEvent('brushselected');
    this.chartRendered = this.createLazyEvent('rendered');
    this.chartFinished = this.createLazyEvent('finished');
    this.animationFrameID = null;
    this.resize$ = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();
    this.echarts = config.echarts;
  }

  ngOnChanges(changes) {
    const filter = ChangeFilter.of(changes);
    filter.notFirstAndEmpty('options').subscribe(opt => this.onOptionsChange(opt));
    filter.notFirstAndEmpty('merge').subscribe(opt => this.setOption(opt));
    filter.has('loading').subscribe(v => this.toggleLoading(!!v));
    filter.notFirst('theme').subscribe(() => this.refreshChart());
  }

  ngOnInit() {
    if (!window.ResizeObserver) {
      throw new Error('please install a polyfill for ResizeObserver');
    }

    this.resizeSub = this.resize$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.throttleTime)(100, rxjs__WEBPACK_IMPORTED_MODULE_5__.asyncScheduler, {
      leading: false,
      trailing: true
    })).subscribe(() => this.resize());

    if (this.autoResize) {
      this.resizeOb = this.ngZone.runOutsideAngular(() => new window.ResizeObserver(() => {
        this.animationFrameID = window.requestAnimationFrame(() => this.resize$.next());
      }));
      this.resizeOb.observe(this.el.nativeElement);
    }
  }

  ngOnDestroy() {
    window.clearTimeout(this.initChartTimer);

    if (this.resizeSub) {
      this.resizeSub.unsubscribe();
    }

    if (this.animationFrameID) {
      window.cancelAnimationFrame(this.animationFrameID);
    }

    if (this.resizeOb) {
      this.resizeOb.unobserve(this.el.nativeElement);
    }

    this.dispose();
  }

  ngAfterViewInit() {
    this.initChartTimer = window.setTimeout(() => this.initChart());
  }

  dispose() {
    if (this.chart) {
      if (!this.chart.isDisposed()) {
        this.chart.dispose();
      }

      this.chart = null;
    }
  }
  /**
   * resize chart
   */


  resize() {
    if (this.chart) {
      this.chart.resize();
    }
  }

  toggleLoading(loading) {
    if (this.chart) {
      loading ? this.chart.showLoading(this.loadingType, this.loadingOpts) : this.chart.hideLoading();
    }
  }

  setOption(option, opts) {
    if (this.chart) {
      try {
        this.chart.setOption(option, opts);
      } catch (e) {
        console.error(e);
        this.optionsError.emit(e);
      }
    }
  }
  /**
   * dispose old chart and create a new one.
   */


  refreshChart() {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__awaiter)(this, void 0, void 0, function* () {
      this.dispose();
      yield this.initChart();
    });
  }

  createChart() {
    const dom = this.el.nativeElement;

    if (window && window.getComputedStyle) {
      const prop = window.getComputedStyle(dom, null).getPropertyValue('height');

      if ((!prop || prop === '0px') && (!dom.style.height || dom.style.height === '0px')) {
        dom.style.height = '400px';
      }
    } // here a bit tricky: we check if the echarts module is provided as function returning native import('...') then use the promise
    // otherwise create the function that imitates behaviour above with a provided as is module


    return this.ngZone.runOutsideAngular(() => {
      const load = typeof this.echarts === 'function' ? this.echarts : () => Promise.resolve(this.echarts);
      return load().then(({
        init
      }) => init(dom, this.theme, this.initOpts));
    });
  }

  initChart() {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__awaiter)(this, void 0, void 0, function* () {
      yield this.onOptionsChange(this.options);

      if (this.merge && this.chart) {
        this.setOption(this.merge);
      }
    });
  }

  onOptionsChange(opt) {
    return (0,tslib__WEBPACK_IMPORTED_MODULE_6__.__awaiter)(this, void 0, void 0, function* () {
      if (!opt) {
        return;
      }

      if (this.chart) {
        this.setOption(this.options, true);
      } else {
        this.chart = yield this.createChart();
        this.chartInit.emit(this.chart);
        this.setOption(this.options, true);
      }
    });
  } // allows to lazily bind to only those events that are requested through the `@Output` by parent components
  // see https://stackoverflow.com/questions/51787972/optimal-reentering-the-ngzone-from-eventemitter-event for more info


  createLazyEvent(eventName) {
    return this.chartInit.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.switchMap)(chart => new rxjs__WEBPACK_IMPORTED_MODULE_8__.Observable(observer => {
      chart.on(eventName, data => this.ngZone.run(() => observer.next(data)));
      return () => {
        if (this.chart) {
          if (!this.chart.isDisposed()) {
            chart.off(eventName);
          }
        }
      };
    })));
  }

}

NgxEchartsDirective.ɵfac = function NgxEchartsDirective_Factory(t) {
  return new (t || NgxEchartsDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](NGX_ECHARTS_CONFIG), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone));
};

NgxEchartsDirective.ɵdir = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineDirective"]({
  type: NgxEchartsDirective,
  selectors: [["echarts"], ["", "echarts", ""]],
  inputs: {
    options: "options",
    theme: "theme",
    loading: "loading",
    initOpts: "initOpts",
    merge: "merge",
    autoResize: "autoResize",
    loadingType: "loadingType",
    loadingOpts: "loadingOpts"
  },
  outputs: {
    chartInit: "chartInit",
    optionsError: "optionsError",
    chartClick: "chartClick",
    chartDblClick: "chartDblClick",
    chartMouseDown: "chartMouseDown",
    chartMouseMove: "chartMouseMove",
    chartMouseUp: "chartMouseUp",
    chartMouseOver: "chartMouseOver",
    chartMouseOut: "chartMouseOut",
    chartGlobalOut: "chartGlobalOut",
    chartContextMenu: "chartContextMenu",
    chartLegendSelectChanged: "chartLegendSelectChanged",
    chartLegendSelected: "chartLegendSelected",
    chartLegendUnselected: "chartLegendUnselected",
    chartLegendScroll: "chartLegendScroll",
    chartDataZoom: "chartDataZoom",
    chartDataRangeSelected: "chartDataRangeSelected",
    chartTimelineChanged: "chartTimelineChanged",
    chartTimelinePlayChanged: "chartTimelinePlayChanged",
    chartRestore: "chartRestore",
    chartDataViewChanged: "chartDataViewChanged",
    chartMagicTypeChanged: "chartMagicTypeChanged",
    chartPieSelectChanged: "chartPieSelectChanged",
    chartPieSelected: "chartPieSelected",
    chartPieUnselected: "chartPieUnselected",
    chartMapSelectChanged: "chartMapSelectChanged",
    chartMapSelected: "chartMapSelected",
    chartMapUnselected: "chartMapUnselected",
    chartAxisAreaSelected: "chartAxisAreaSelected",
    chartFocusNodeAdjacency: "chartFocusNodeAdjacency",
    chartUnfocusNodeAdjacency: "chartUnfocusNodeAdjacency",
    chartBrush: "chartBrush",
    chartBrushEnd: "chartBrushEnd",
    chartBrushSelected: "chartBrushSelected",
    chartRendered: "chartRendered",
    chartFinished: "chartFinished"
  },
  exportAs: ["echarts"],
  features: [_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵNgOnChangesFeature"]]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](NgxEchartsDirective, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,
    args: [{
      selector: 'echarts, [echarts]',
      exportAs: 'echarts'
    }]
  }], function () {
    return [{
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
        args: [NGX_ECHARTS_CONFIG]
      }]
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone
    }];
  }, {
    options: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    theme: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    loading: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    initOpts: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    merge: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    autoResize: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    loadingType: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    loadingOpts: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
    }],
    chartInit: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    optionsError: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartClick: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartDblClick: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMouseDown: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMouseMove: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMouseUp: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMouseOver: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMouseOut: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartGlobalOut: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartContextMenu: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartLegendSelectChanged: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartLegendSelected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartLegendUnselected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartLegendScroll: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartDataZoom: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartDataRangeSelected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartTimelineChanged: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartTimelinePlayChanged: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartRestore: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartDataViewChanged: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMagicTypeChanged: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartPieSelectChanged: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartPieSelected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartPieUnselected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMapSelectChanged: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMapSelected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartMapUnselected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartAxisAreaSelected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartFocusNodeAdjacency: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartUnfocusNodeAdjacency: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartBrush: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartBrushEnd: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartBrushSelected: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartRendered: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }],
    chartFinished: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
    }]
  });
})();

class NgxEchartsModule {
  static forRoot(config) {
    return {
      ngModule: NgxEchartsModule,
      providers: [{
        provide: NGX_ECHARTS_CONFIG,
        useValue: config
      }]
    };
  }

  static forChild() {
    return {
      ngModule: NgxEchartsModule
    };
  }

}

NgxEchartsModule.ɵfac = function NgxEchartsModule_Factory(t) {
  return new (t || NgxEchartsModule)();
};

NgxEchartsModule.ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"]({
  type: NgxEchartsModule
});
NgxEchartsModule.ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjector"]({
  imports: [[]]
});

(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](NgxEchartsModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgModule,
    args: [{
      imports: [],
      declarations: [NgxEchartsDirective],
      exports: [NgxEchartsDirective]
    }]
  }], null, null);
})();
/*
 * Public API Surface of ngx-echarts
 */

/**
 * Generated bundle index. Do not edit.
 */




/***/ })

}]);
//# sourceMappingURL=default-node_modules_ngx-echarts_fesm2015_ngx-echarts_mjs.js.map